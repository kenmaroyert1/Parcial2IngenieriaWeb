import pandas as pd
import os
import sys
from datetime import datetime

# Agregar el directorio padre al path para importar m√≥dulos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from Config.Config import Config
from Extract.Extract import Extract
from Clean.Clean import Clean
from Load.Load import Load

class TestETL:
    """Clase para probar el proceso ETL con los primeros 50 registros"""
    
    def __init__(self):
        self.test_results = {
            'extract': False,
            'clean': False,
            'load': False,
            'errors': [],
            'warnings': []
        }
        self.start_time = datetime.now()
    
    def run_all_tests(self):
        """Ejecuta todas las pruebas del proceso ETL"""
        print("üß™ Iniciando pruebas del proceso ETL...")
        print("=" * 60)
        
        # Test de extracci√≥n
        self.test_extract()
        
        # Si la extracci√≥n es exitosa, continuar con limpieza
        if self.test_results['extract']:
            self.test_clean()
        
        # Si la limpieza es exitosa, continuar con carga
        if self.test_results['clean']:
            self.test_load()
        
        # Mostrar resumen
        self.show_summary()
    
    def test_extract(self):
        """Prueba el m√≥dulo de extracci√≥n"""
        print("\nüì• Probando m√≥dulo de Extracci√≥n...")
        
        try:
            # Verificar que el archivo existe
            if not os.path.exists(Config.INPUT_PATH):
                self.test_results['errors'].append(f"Archivo CSV no encontrado: {Config.INPUT_PATH}")
                print(f"‚ùå Error: Archivo CSV no encontrado")
                return
            
            # Crear extractor
            extractor = Extract(Config.INPUT_PATH)
            
            # Obtener informaci√≥n del archivo
            info = extractor.get_data_info()
            if 'error' in info:
                self.test_results['errors'].append(f"Error al obtener info del archivo: {info['error']}")
                print(f"‚ùå Error al obtener informaci√≥n del archivo")
                return
            
            print(f"‚úÖ Archivo encontrado: {info['total_records']} registros totales")
            print(f"üìã Columnas: {info['columns']}")
            
            # Extraer primeros 50 registros
            df = extractor.extract_first_n_rows(50)
            
            if df is None:
                self.test_results['errors'].append("Error al extraer datos del CSV")
                print("‚ùå Error al extraer datos")
                return
            
            # Validaciones
            if len(df) != 50:
                self.test_results['warnings'].append(f"Se esperaban 50 registros, se obtuvieron {len(df)}")
            
            required_columns = ['#', 'Name', 'Type 1', 'HP', 'Attack', 'Defense']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                self.test_results['errors'].append(f"Columnas faltantes: {missing_columns}")
                print(f"‚ùå Columnas faltantes: {missing_columns}")
                return
            
            self.df_extracted = df
            self.test_results['extract'] = True
            print(f"‚úÖ Extracci√≥n exitosa: {len(df)} registros, {len(df.columns)} columnas")
            
        except Exception as e:
            self.test_results['errors'].append(f"Error en extracci√≥n: {str(e)}")
            print(f"‚ùå Error en extracci√≥n: {str(e)}")
    
    def test_clean(self):
        """Prueba el m√≥dulo de limpieza"""
        print("\nüßπ Probando m√≥dulo de Limpieza...")
        
        try:
            # Crear limpiador
            cleaner = Clean(self.df_extracted)
            
            # Ejecutar limpieza
            df_clean = cleaner.clean_data()
            
            if df_clean is None or df_clean.empty:
                self.test_results['errors'].append("Error: DataFrame limpio est√° vac√≠o")
                print("‚ùå Error: DataFrame limpio est√° vac√≠o")
                return
            
            # Validaciones despu√©s de la limpieza
            expected_columns = ['id', 'nombre', 'tipo_principal', 'hp', 'ataque', 'defensa']
            missing_columns = [col for col in expected_columns if col not in df_clean.columns]
            if missing_columns:
                self.test_results['errors'].append(f"Columnas esperadas faltantes despu√©s de limpieza: {missing_columns}")
                print(f"‚ùå Columnas faltantes despu√©s de limpieza: {missing_columns}")
                return
            
            # Verificar que no hay valores nulos en columnas cr√≠ticas
            critical_columns = ['id', 'nombre', 'tipo_principal']
            for col in critical_columns:
                if col in df_clean.columns and df_clean[col].isnull().any():
                    self.test_results['warnings'].append(f"Valores nulos encontrados en columna cr√≠tica: {col}")
            
            # Verificar tipos de datos
            numeric_columns = ['id', 'hp', 'ataque', 'defensa']
            for col in numeric_columns:
                if col in df_clean.columns and not pd.api.types.is_numeric_dtype(df_clean[col]):
                    self.test_results['warnings'].append(f"Columna {col} no es num√©rica despu√©s de limpieza")
            
            # Obtener resumen de limpieza
            summary = cleaner.get_data_summary()
            print(f"‚úÖ Limpieza exitosa:")
            print(f"   - Pokemon procesados: {summary['total_pokemon']}")
            print(f"   - Tipos √∫nicos: {len(summary['tipos_principales'])}")
            print(f"   - Pokemon legendarios: {summary['pokemon_legendarios']}")
            
            self.df_clean = df_clean
            self.test_results['clean'] = True
            
        except Exception as e:
            self.test_results['errors'].append(f"Error en limpieza: {str(e)}")
            print(f"‚ùå Error en limpieza: {str(e)}")
    
    def test_load(self):
        """Prueba el m√≥dulo de carga"""
        print("\nüì§ Probando m√≥dulo de Carga...")
        
        try:
            # Crear cargador
            loader = Load(self.df_clean)
            
            # Validar integridad de datos
            validation = loader.validate_data_integrity()
            if not validation['is_valid']:
                for issue in validation['issues']:
                    self.test_results['errors'].append(f"Problema de integridad: {issue}")
                print("‚ùå Problemas de integridad de datos")
                return
            
            if validation['warnings']:
                for warning in validation['warnings']:
                    self.test_results['warnings'].append(f"Advertencia de integridad: {warning}")
            
            # Probar guardado en CSV
            test_csv_path = Config.OUTPUT_PATH.replace('.csv', '_test.csv')
            csv_result = loader.to_csv(test_csv_path, include_timestamp=False)
            
            if csv_result:
                print(f"‚úÖ CSV guardado exitosamente en: {csv_result}")
                
                # Verificar que el archivo se cre√≥ y tiene contenido
                if os.path.exists(csv_result):
                    file_size = os.path.getsize(csv_result)
                    if file_size > 0:
                        print(f"   üìä Tama√±o del archivo: {file_size} bytes")
                    else:
                        self.test_results['warnings'].append("El archivo CSV est√° vac√≠o")
                else:
                    self.test_results['errors'].append("El archivo CSV no se cre√≥ correctamente")
                    return
            else:
                self.test_results['errors'].append("Error al guardar CSV")
                return
            
            # Probar guardado en JSON (opcional)
            try:
                test_json_path = test_csv_path.replace('.csv', '.json')
                json_result = loader.to_json(test_json_path, include_timestamp=False)
                if json_result:
                    print(f"‚úÖ JSON guardado exitosamente en: {json_result}")
                else:
                    self.test_results['warnings'].append("No se pudo guardar en formato JSON")
            except Exception as e:
                self.test_results['warnings'].append(f"Error al guardar JSON: {str(e)}")
            
            # Obtener resumen de carga
            summary = loader.get_load_summary()
            print(f"‚úÖ Carga exitosa:")
            print(f"   - Registros cargados: {summary['total_records']}")
            print(f"   - Uso de memoria: {summary['memory_usage']}")
            
            self.test_results['load'] = True
            
        except Exception as e:
            self.test_results['errors'].append(f"Error en carga: {str(e)}")
            print(f"‚ùå Error en carga: {str(e)}")
    
    def show_summary(self):
        """Muestra un resumen de todas las pruebas"""
        print("\n" + "=" * 60)
        print("üìä RESUMEN DE PRUEBAS ETL")
        print("=" * 60)
        
        # Tiempo total
        duration = datetime.now() - self.start_time
        print(f"‚è±Ô∏è Tiempo total: {duration.total_seconds():.2f} segundos")
        
        # Resultados por m√≥dulo
        modules = [
            ('Extracci√≥n', 'extract'),
            ('Limpieza', 'clean'),
            ('Carga', 'load')
        ]
        
        for module_name, module_key in modules:
            status = "‚úÖ EXITOSO" if self.test_results[module_key] else "‚ùå FALLIDO"
            print(f"{module_name}: {status}")
        
        # Errores
        if self.test_results['errors']:
            print(f"\n‚ùå Errores encontrados ({len(self.test_results['errors'])}):")
            for i, error in enumerate(self.test_results['errors'], 1):
                print(f"   {i}. {error}")
        
        # Advertencias
        if self.test_results['warnings']:
            print(f"\n‚ö†Ô∏è Advertencias ({len(self.test_results['warnings'])}):")
            for i, warning in enumerate(self.test_results['warnings'], 1):
                print(f"   {i}. {warning}")
        
        # Resultado general
        all_passed = all([
            self.test_results['extract'],
            self.test_results['clean'],
            self.test_results['load']
        ])
        
        if all_passed:
            print(f"\nüéâ TODAS LAS PRUEBAS PASARON EXITOSAMENTE")
            print("El proceso ETL est√° funcionando correctamente con los primeros 50 registros.")
        else:
            print(f"\nüí• ALGUNAS PRUEBAS FALLARON")
            print("Revisa los errores anteriores antes de continuar.")
        
        print("=" * 60)


def run_basic_test():
    """Funci√≥n para ejecutar una prueba b√°sica r√°pida"""
    print("üöÄ Ejecutando prueba b√°sica del ETL...")
    
    try:
        # Verificar configuraci√≥n
        print(f"üìÅ Archivo de entrada: {Config.INPUT_PATH}")
        print(f"üìÅ Archivo de salida: {Config.OUTPUT_PATH}")
        
        if not os.path.exists(Config.INPUT_PATH):
            print("‚ùå Error: Archivo Pokemon.csv no encontrado")
            return False
        
        # Prueba r√°pida de cada m√≥dulo
        print("\nüîç Probando Extract...")
        extractor = Extract(Config.INPUT_PATH)
        df = extractor.extract_first_n_rows(5)  # Solo 5 registros para prueba r√°pida
        
        if df is None:
            print("‚ùå Error en Extract")
            return False
        print(f"‚úÖ Extract OK - {len(df)} registros")
        
        print("\nüîç Probando Clean...")
        cleaner = Clean(df)
        df_clean = cleaner.clean_data()
        
        if df_clean is None or df_clean.empty:
            print("‚ùå Error en Clean")
            return False
        print(f"‚úÖ Clean OK - {len(df_clean)} registros limpios")
        
        print("\nüîç Probando Load...")
        loader = Load(df_clean)
        test_path = "test_output.csv"
        result = loader.to_csv(test_path, include_timestamp=False)
        
        if result and os.path.exists(result):
            print(f"‚úÖ Load OK - Archivo guardado: {result}")
            # Limpiar archivo de prueba
            try:
                os.remove(result)
            except:
                pass
            return True
        else:
            print("‚ùå Error en Load")
            return False
            
    except Exception as e:
        print(f"‚ùå Error en prueba b√°sica: {str(e)}")
        return False


if __name__ == "__main__":
    # Permitir elegir entre prueba b√°sica o completa
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "basic":
        success = run_basic_test()
        if success:
            print("\nüéâ Prueba b√°sica completada exitosamente")
        else:
            print("\nüí• Prueba b√°sica fall√≥")
    else:
        # Ejecutar pruebas completas
        test_runner = TestETL()
        test_runner.run_all_tests()
